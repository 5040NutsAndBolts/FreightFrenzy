Index: TeamCode/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\r\n// build.gradle in TeamCode\r\n//\r\n// Most of the definitions for building your module reside in a common, shared\r\n// file 'build.common.gradle'. Being factored in this way makes it easier to\r\n// integrate updates to the FTC into your code. If you really need to customize\r\n// the build definitions, you can place those customizations in this file, but\r\n// please think carefully as to whether such customizations are really necessary\r\n// before doing so.\r\n\r\n\r\n// Custom definitions may go here\r\n\r\n// Include common definitions from above.\r\napply from: '../build.common.gradle'\r\napply from: '../build.dependencies.gradle'\r\n\r\ndependencies {\r\n    implementation project(':FtcRobotController')\r\n    annotationProcessor files('lib/OpModeAnnotationProcessor.jar')\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/build.gradle	(revision bb5e5f6589d5aa24027340759f83164d23ef3201)
+++ TeamCode/build.gradle	(date 1638883756457)
@@ -19,3 +19,7 @@
     implementation project(':FtcRobotController')
     annotationProcessor files('lib/OpModeAnnotationProcessor.jar')
 }
+dependencies {
+    //NOTE: this is the correct version, the below screenshot is outdated
+    implementation 'org.openftc:rev-extensions-2:1.2'
+}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Teleop.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\n\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\n\r\n@TeleOp(name=\"Teleop\",group=\"Teleop\")\r\npublic class Teleop extends LinearOpMode\r\n{\r\n\r\n    boolean x2Pressed = false;\r\n    boolean a2Pressed = false;\r\n    boolean a1Pressed = false;\r\n    boolean rightRampUp = true;\r\n    boolean leftRampUp = true;\r\n    boolean intakeUp = true;\r\n\r\n\r\n    @Override\r\n    public void runOpMode() throws InterruptedException\r\n    {\r\n\r\n        Hardware robot = new Hardware(hardwareMap);\r\n\r\n        waitForStart();\r\n        //setting position for the ramp servo start\r\n        robot.depositNeutral();\r\n        robot.rightRampUp();\r\n        robot.leftRampUp();\r\n\r\n        Hardware.currentOpMode=this;\r\n        robot.startIntakeThread();\r\n\r\n        while (opModeIsActive())\r\n        {\r\n\r\n            //Slide outtake motor controller set up (linear slides)\r\n            robot.depositSlide.setPower(gamepad2.left_stick_y);\r\n\r\n            //Move freight into correct deposit side\r\n            if(gamepad2.dpad_left)\r\n                robot.depositLeft();\r\n            else if(gamepad2.dpad_right)\r\n                robot.depositRight();\r\n            else if(gamepad2.dpad_up)\r\n                robot.depositNeutral();\r\n\r\n            //Toggle left ramp when x is pressed\r\n            if (!x2Pressed && gamepad2.x)\r\n            {\r\n                x2Pressed = true;\r\n                leftRampUp = !leftRampUp;\r\n            } else if (!gamepad2.x)\r\n                x2Pressed = false;\r\n\r\n            if(leftRampUp)\r\n                robot.leftRampUp();\r\n            else\r\n                robot.leftRampDown();\r\n\r\n            //Toggle right ramp when b is pressed\r\n            if (!a2Pressed&&gamepad2.a) {\r\n\r\n                a2Pressed = true;\r\n                rightRampUp=!rightRampUp;\r\n\r\n            }\r\n            else if (!gamepad2.a)\r\n                a2Pressed = false;\r\n\r\n            if(rightRampUp)\r\n                robot.rightRampUp();\r\n            else\r\n                robot.rightRampDown();\r\n\r\n            //Set intake power\r\n            if(gamepad1.right_trigger>0)\r\n                robot.setIntakePower(-gamepad1.right_trigger);\r\n            else\r\n                robot.setIntakePower(gamepad1.left_trigger);\r\n\r\n            //Set drivetrain power\r\n            robot.drive(gamepad1.left_stick_y,gamepad1.left_stick_x,gamepad1.right_stick_x);\r\n\r\n            //Set duck spinner power\r\n            robot.setLeftDuckSpinnerPower(gamepad2.left_trigger);\r\n            robot.setRightDuckSpinnerPower(gamepad2.right_trigger);\r\n\r\n            //Toggle Intake Arm Up & Down when gamepad1.a is pressed\r\n            if (!a1Pressed && gamepad1.a)\r\n            {\r\n                a1Pressed = true;\r\n                intakeUp = !intakeUp;\r\n            } else if (!gamepad1.a)\r\n                a1Pressed = false;\r\n\r\n            if(intakeUp)\r\n                robot.intakeArmUp();\r\n            else\r\n            {\r\n                if(robot.intakeArmPosition()>30)\r\n                    robot.closeIntake();\r\n                robot.intakeArmDown();\r\n            }\r\n\r\n            if(robot.intakeArmPosition()<30)\r\n                robot.openIntake();\r\n\r\n\r\n            telemetry.addData(\"intake arm position\",robot.intakeArmPosition());\r\n            telemetry.addData(\"deposit position\", robot.depositPosition());\r\n            telemetry.update();\r\n\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Teleop.java	(revision bb5e5f6589d5aa24027340759f83164d23ef3201)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Teleop.java	(date 1638923836275)
@@ -7,6 +7,8 @@
 import com.qualcomm.robotcore.hardware.HardwareMap;
 import com.qualcomm.robotcore.hardware.Servo;
 
+import org.firstinspires.ftc.robotcore.external.navigation.TempUnit;
+
 @TeleOp(name="Teleop",group="Teleop")
 public class Teleop extends LinearOpMode
 {
@@ -37,6 +39,8 @@
         while (opModeIsActive())
         {
 
+            robot.updateInchesMoved();
+
             //Slide outtake motor controller set up (linear slides)
             robot.depositSlide.setPower(gamepad2.left_stick_y);
 
@@ -110,8 +114,12 @@
                 robot.openIntake();
 
 
-            telemetry.addData("intake arm position",robot.intakeArmPosition());
-            telemetry.addData("deposit position", robot.depositPosition());
+            telemetry.addData("Intake arm position",robot.intakeArmPosition());
+            telemetry.addData("Deposit position", robot.depositPosition());
+            telemetry.addData("Temp", robot.imu.getTemperature().toUnit(TempUnit.FARENHEIT)+"Â°F");
+            telemetry.addData("x",robot.x);
+            telemetry.addData("y",robot.y);
+            telemetry.addData("theta",robot.theta);
             telemetry.update();
 
         }
Index: build.common.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * build.common.gradle\r\n *\r\n * Try to avoid editing this file, as it may be updated from time to time as the FTC SDK\r\n * evolves. Rather, if it is necessary to customize the build process, do those edits in\r\n * the build.gradle file in TeamCode.\r\n *\r\n * This file contains the necessary content of the 'build.gradle' files for robot controller\r\n * applications built using the FTC SDK. Each individual 'build.gradle' in those applications\r\n * can simply contain the one line:\r\n *\r\n *      apply from: '../build.common.gradle'\r\n *\r\n * which will pick up this file here. This approach allows makes it easier to integrate\r\n * updates to the FTC SDK into your code.\r\n */\r\n\r\nimport java.util.regex.Pattern\r\n\r\napply plugin: 'com.android.application'\r\n\r\nandroid {\r\n\r\n    compileSdkVersion 29\r\n\r\n    signingConfigs {\r\n        release {\r\n            def apkStoreFile = System.getenv(\"APK_SIGNING_STORE_FILE\")\r\n            if (apkStoreFile != null) {\r\n                keyAlias System.getenv(\"APK_SIGNING_KEY_ALIAS\")\r\n                keyPassword System.getenv(\"APK_SIGNING_KEY_PASSWORD\")\r\n                storeFile file(System.getenv(\"APK_SIGNING_STORE_FILE\"))\r\n                storePassword System.getenv(\"APK_SIGNING_STORE_PASSWORD\")\r\n            } else {\r\n                keyAlias 'androiddebugkey'\r\n                keyPassword 'android'\r\n                storeFile rootProject.file('libs/ftc.debug.keystore')\r\n                storePassword 'android'\r\n            }\r\n        }\r\n\r\n        debug {\r\n            keyAlias 'androiddebugkey'\r\n            keyPassword 'android'\r\n            storeFile rootProject.file('libs/ftc.debug.keystore')\r\n            storePassword 'android'\r\n        }\r\n    }\r\n\r\n    aaptOptions {\r\n        noCompress \"tflite\"\r\n    }\r\n\r\n    defaultConfig {\r\n        signingConfig signingConfigs.debug\r\n        applicationId 'com.qualcomm.ftcrobotcontroller'\r\n        minSdkVersion 23\r\n        //noinspection ExpiredTargetSdkVersion\r\n        targetSdkVersion 28\r\n\r\n        /**\r\n         * We keep the versionCode and versionName of robot controller applications in sync with\r\n         * the master information published in the AndroidManifest.xml file of the FtcRobotController\r\n         * module. This helps avoid confusion that might arise from having multiple versions of\r\n         * a robot controller app simultaneously installed on a robot controller device.\r\n         *\r\n         * We accomplish this with the help of a funky little Groovy script that maintains that\r\n         * correspondence automatically.\r\n         *\r\n         * @see <a href=\"http://developer.android.com/tools/building/configuring-gradle.html\">Configure Your Build</a>\r\n         * @see <a href=\"http://developer.android.com/tools/publishing/versioning.html\">Versioning Your App</a>\r\n         */\r\n        def manifestFile = project(':FtcRobotController').file('src/main/AndroidManifest.xml');\r\n        def manifestText = manifestFile.getText()\r\n        //\r\n        def vCodePattern = Pattern.compile(\"versionCode=\\\"(\\\\d+(\\\\.\\\\d+)*)\\\"\")\r\n        def matcher = vCodePattern.matcher(manifestText)\r\n        matcher.find()\r\n        def vCode = Integer.parseInt(matcher.group(1))\r\n        //\r\n        def vNamePattern = Pattern.compile(\"versionName=\\\"(.*)\\\"\")\r\n        matcher = vNamePattern.matcher(manifestText);\r\n        matcher.find()\r\n        def vName = matcher.group(1)\r\n        //\r\n        versionCode vCode\r\n        versionName vName\r\n    }\r\n\r\n    // Advanced user code might just want to use Vuforia directly, so we set up the libs as needed\r\n    // http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html\r\n    buildTypes {\r\n        release {\r\n            signingConfig signingConfigs.release\r\n\r\n            ndk {\r\n                abiFilters \"armeabi-v7a\", \"arm64-v8a\"\r\n            }\r\n        }\r\n        debug {\r\n            debuggable true\r\n            jniDebuggable true\r\n            renderscriptDebuggable true\r\n            ndk {\r\n                abiFilters \"armeabi-v7a\", \"arm64-v8a\"\r\n            }\r\n        }\r\n    }\r\n\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n\r\n    packagingOptions {\r\n        pickFirst '**/*.so'\r\n    }\r\n    sourceSets.main {\r\n        jni.srcDirs = []\r\n        jniLibs.srcDir rootProject.file('libs')\r\n    }\r\n    ndkVersion '21.3.6528147'\r\n}\r\n\r\nrepositories {\r\n    flatDir {\r\n        dirs rootProject.file('libs')\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- build.common.gradle	(revision bb5e5f6589d5aa24027340759f83164d23ef3201)
+++ build.common.gradle	(date 1638883756467)
@@ -126,5 +126,6 @@
     flatDir {
         dirs rootProject.file('libs')
     }
+    jcenter()
 }
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.CRServo;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\n\r\nimport org.firstinspires.ftc.teamcode.helperclasses.ThreadPool;\r\n\r\nimport static java.lang.Math.abs;\r\n\r\npublic class Hardware\r\n{\r\n\r\n    //The linear slide motors\r\n    public DcMotor depositSlide;\r\n\r\n    private CRServo leftDuckSpinner;\r\n    private CRServo rightDuckSpinner;\r\n\r\n    //drive train motors\r\n    private DcMotor frontLeft;\r\n    private DcMotor backLeft;\r\n    private DcMotor frontRight;\r\n    private DcMotor backRight;\r\n\r\n    private DcMotor intakeArm;\r\n    private CRServo intakeSweeper;\r\n\r\n    //Deposit servo flicker and ramps\r\n    private Servo depositFlicker;\r\n    private Servo rightRamp;\r\n    private Servo leftRamp;\r\n    private Servo intakeBlocker;\r\n\r\n    private byte depositLevel=0;\r\n\r\n    public static LinearOpMode currentOpMode;\r\n\r\n    private boolean intakeUp = true;\r\n\r\n    public ThreadPool hardwarePool;\r\n\r\n    public Hardware(HardwareMap hardwareMap)\r\n    {\r\n\r\n        //Intake\r\n        intakeSweeper = hardwareMap.crservo.get(\"Intake Sweeper\");\r\n        intakeArm = hardwareMap.dcMotor.get(\"Intake Arm\");\r\n        intakeBlocker = hardwareMap.servo.get(\"Intake Blocker\");\r\n        intakeArm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        intakeArm.setTargetPosition(0);\r\n        intakeArm.setPower(1);\r\n        intakeArm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        //intakeArm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n        //Duck spinners\r\n        leftDuckSpinner = hardwareMap.crservo.get(\"Left Duck Spinner\");\r\n        rightDuckSpinner = hardwareMap.crservo.get(\"Right Duck Spinner\");\r\n\r\n        //Drive motors\r\n        frontLeft = hardwareMap.dcMotor.get(\"Front Left\");\r\n        backLeft = hardwareMap.dcMotor.get(\"Back Left\");\r\n        frontRight = hardwareMap.dcMotor.get(\"Front Right\");\r\n        backRight = hardwareMap.dcMotor.get(\"Back Right\");\r\n\r\n        frontRight.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        backRight.setDirection(DcMotorSimple.Direction.REVERSE);\r\n\r\n        frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n        //Deposit\r\n        depositSlide = hardwareMap.get(DcMotor.class, \"Deposit Slide\");\r\n        //depositSlide.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        leftRamp = hardwareMap.get(Servo.class, \"Left Ramp\");\r\n        rightRamp = hardwareMap.get(Servo.class, \"Right Ramp\");\r\n        depositFlicker = hardwareMap.get(Servo.class, \"Deposit Flicker\");\r\n\r\n    }\r\n\r\n    //Deposit ramp positions\r\n    public void leftRampUp(){leftRamp.setPosition(.8);}\r\n    public void leftRampDown(){leftRamp.setPosition(.57);}\r\n    public void rightRampUp(){rightRamp.setPosition(.48);}\r\n    public void rightRampDown(){rightRamp.setPosition(.69);}\r\n\r\n    //Deposit flicker positions\r\n    public void depositLeft(){depositFlicker.setPosition(.25);}\r\n    public void depositRight(){depositFlicker.setPosition(.75);}\r\n    public void depositNeutral(){depositFlicker.setPosition(.5);}\r\n    public int depositPosition(){return depositSlide.getCurrentPosition();}\r\n\r\n    private Thread depositBrakeManager = new Thread()\r\n    {\r\n        @Override\r\n        public void run()\r\n        {\r\n\r\n            while(currentOpMode.opModeIsActive())\r\n            {\r\n                if ((depositLevel==0))\r\n                {\r\n                    if (depositSlide.getCurrentPosition() < 4)\r\n                    {\r\n                        depositSlide.setPower(0);\r\n                        depositSlide.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n                    } else\r\n                    {\r\n                        depositSlide.setTargetPosition(-5);\r\n                        depositSlide.setPower(.2);\r\n                    }\r\n\r\n                } else if(depositLevel == 1)\r\n                {\r\n                    if (depositSlide.getCurrentPosition() < 100)\r\n                    {\r\n                        depositSlide.setPower(.3);\r\n                        depositSlide.setTargetPosition(105);\r\n                    }\r\n                    else if(depositSlide.getCurrentPosition()>110)\r\n                    {\r\n                        depositSlide.setPower(.2);\r\n                        depositSlide.setTargetPosition(105);\r\n                    }\r\n                    else\r\n                    {\r\n                        depositSlide.setPower(0);\r\n                        depositSlide.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n                    }\r\n\r\n                }\r\n                else\r\n                {\r\n\r\n                    if (depositSlide.getCurrentPosition() > 150)\r\n                    {\r\n                        depositSlide.setPower(0);\r\n                        depositSlide.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n                    } else\r\n                    {\r\n                        depositSlide.setTargetPosition(155);\r\n                        depositSlide.setPower(.3);\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    //Run ducks spinners\r\n    public void setLeftDuckSpinnerPower(double power){leftDuckSpinner.setPower(power);}\r\n    public void setRightDuckSpinnerPower(double power){rightDuckSpinner.setPower(power);}\r\n\r\n    //Intake methods\r\n    public void setIntakePower(double power){intakeSweeper.setPower(power);}\r\n    public void intakeArmUp() { intakeUp=true; }\r\n    public void intakeArmDown() { intakeUp=false; }\r\n    public void startIntakeThread()\r\n    {\r\n        ThreadPool.pool.submit(intakeBrakeManager);\r\n    }\r\n    private Thread intakeBrakeManager = new Thread()\r\n    {\r\n        @Override\r\n        public void run()\r\n        {\r\n\r\n            while(currentOpMode.opModeIsActive())\r\n            {\r\n                if ((intakeUp))\r\n                {\r\n                    if (intakeArm.getCurrentPosition() < 4)\r\n                    {\r\n                        intakeArm.setPower(0);\r\n                        intakeArm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n                    } else\r\n                    {\r\n                        intakeArm.setTargetPosition(-5);\r\n                        intakeArm.setPower(1);\r\n                    }\r\n\r\n                } else\r\n                {\r\n                    if (intakeArm.getCurrentPosition() > 160)\r\n                    {\r\n                        intakeArm.setPower(0);\r\n                        intakeArm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n                    } else\r\n                    {\r\n                        intakeArm.setTargetPosition(185);\r\n                        intakeArm.setPower(1);\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    public int intakeArmPosition() {return intakeArm.getCurrentPosition();}\r\n    public void openIntake() {intakeBlocker.setPosition(.14);}\r\n    public void closeIntake(){intakeBlocker.setPosition(.45);}\r\n\r\n\r\n    //Set drive power\r\n    public void drive(double forward, double sideways, double rotation) {\r\n\r\n        //adds all the inputs together to get the number to scale it by\r\n        double scale = abs(rotation) + abs(forward) + abs(sideways);\r\n\r\n        //scales the inputs when needed\r\n        if (scale > 1) {\r\n            forward /= scale;\r\n            rotation /= scale;\r\n            sideways /= scale;\r\n        }\r\n        //setting the motor powers to move\r\n        frontLeft.setPower(forward - rotation - sideways);\r\n        backLeft.setPower(forward - rotation + sideways);\r\n        frontRight.setPower(forward + rotation + sideways);\r\n        backRight.setPower(forward + rotation - sideways);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware.java	(revision bb5e5f6589d5aa24027340759f83164d23ef3201)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware.java	(date 1638922977716)
@@ -7,6 +7,10 @@
 import com.qualcomm.robotcore.hardware.HardwareMap;
 import com.qualcomm.robotcore.hardware.Servo;
 
+import org.openftc.revextensions2.ExpansionHubEx;
+import org.openftc.revextensions2.ExpansionHubMotor;
+import org.openftc.revextensions2.RevBulkData;
+
 import org.firstinspires.ftc.teamcode.helperclasses.ThreadPool;
 
 import static java.lang.Math.abs;
@@ -43,6 +47,20 @@
 
     public ThreadPool hardwarePool;
 
+    public RevBulkData bulkData;
+    public ExpansionHubEx expansionHub;
+
+    private int frontLeftTicks;
+    private int backLeftTicks;
+    private int frontRightTicks;
+    private int backRightTicks;
+
+    public double x=0;
+    public double y=0;
+    public double theta=0;
+
+    private static final double inchesPerTick=11/1440;
+
     public Hardware(HardwareMap hardwareMap)
     {
 
@@ -76,6 +94,7 @@
 
         //Deposit
         depositSlide = hardwareMap.get(DcMotor.class, "Deposit Slide");
+        depositSlide.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
         //depositSlide.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
         leftRamp = hardwareMap.get(Servo.class, "Left Ramp");
         rightRamp = hardwareMap.get(Servo.class, "Right Ramp");
@@ -95,6 +114,8 @@
     public void depositNeutral(){depositFlicker.setPosition(.5);}
     public int depositPosition(){return depositSlide.getCurrentPosition();}
 
+
+
     private Thread depositBrakeManager = new Thread()
     {
         @Override
@@ -112,7 +133,7 @@
                     } else
                     {
                         depositSlide.setTargetPosition(-5);
-                        depositSlide.setPower(.2);
+                        depositSlide.setPower(.3);
                     }
 
                 } else if(depositLevel == 1)
@@ -124,7 +145,7 @@
                     }
                     else if(depositSlide.getCurrentPosition()>110)
                     {
-                        depositSlide.setPower(.2);
+                        depositSlide.setPower(.3);
                         depositSlide.setTargetPosition(105);
                     }
                     else
@@ -201,10 +222,41 @@
         }
     };
 
+    public void updateInchesMoved()
+    {
+
+        double inchesLF = getDeltaFrontLeftTicks()* inchesPerTick;
+        double inchesLB = getDeltaBackLeftTicks() * inchesPerTick;
+        double inchesRF = getDeltaFrontRightTicks() * inchesPerTick;
+        double inchesRB = getDeltaBackRightTicks() * inchesPerTick;
+
+        double inchesForward = (inchesLF + inchesLB + inchesRF + inchesRB) / 4;
+        double inchesSideways = (-inchesLF + inchesLB + inchesRF - inchesRB) / 4;
+
+        theta=imu;
+        y+=inchesForward*Math.cos(theta)+inchesSideways*Math.sin(theta);
+        x+=inchesForward*Math.sin(theta)+inchesSideways*Math.cos(theta);
+
+        resetDeltaTicks();
+
+    }
+
     public int intakeArmPosition() {return intakeArm.getCurrentPosition();}
     public void openIntake() {intakeBlocker.setPosition(.14);}
     public void closeIntake(){intakeBlocker.setPosition(.45);}
 
+    public int getDeltaFrontLeftTicks(){return frontLeftTicks-bulkData.getMotorCurrentPosition(frontLeft);}
+    public int getDeltaFrontRightTicks(){return frontRightTicks-bulkData.getMotorCurrentPosition(frontRight);}
+    public int getDeltaBackLeftTicks(){return backLeftTicks-bulkData.getMotorCurrentPosition(backLeft);}
+    public int getDeltaBackRightTicks(){return backRightTicks-bulkData.getMotorCurrentPosition(backRight);}
+
+    public void resetDeltaTicks()
+    {
+        frontLeftTicks=bulkData.getMotorCurrentPosition(frontLeft);
+        frontRightTicks=bulkData.getMotorCurrentPosition(frontRight);
+        backLeftTicks=bulkData.getMotorCurrentPosition(backLeft);
+        backRightTicks=bulkData.getMotorCurrentPosition(backRight);
+    }
 
     //Set drive power
     public void drive(double forward, double sideways, double rotation) {
